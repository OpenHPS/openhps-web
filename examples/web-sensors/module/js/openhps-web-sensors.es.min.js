import*as e from"./openhps-core.es.min.js";var t={229:(t,r,o)=>{const n=(e=>{var t={};return o.d(t,e),t})({AbsoluteOrientationSensor:()=>e.AbsoluteOrientationSensor,Acceleration:()=>e.Acceleration,Accelerometer:()=>e.Accelerometer,AngularVelocity:()=>e.AngularVelocity,AngularVelocityUnit:()=>e.AngularVelocityUnit,DataFrame:()=>e.DataFrame,DataObject:()=>e.DataObject,Gyroscope:()=>e.Gyroscope,LinearAccelerationSensor:()=>e.LinearAccelerationSensor,Magnetism:()=>e.Magnetism,Magnetometer:()=>e.Magnetometer,Orientation:()=>e.Orientation,Quaternion:()=>e.Quaternion,RelativeOrientationSensor:()=>e.RelativeOrientationSensor,SourceNode:()=>e.SourceNode,TimeService:()=>e.TimeService});class SensorSourceNode extends n.SourceNode{constructor(e){super(e),this._subscriptions=new Map,this._values=new Map,this._lastPush=0,this._running=!1,this.options.interval=this.options.interval||100,this.options.autoStart&&this.once("build",this.start.bind(this)),this.once("destroy",this.stop.bind(this))}requestPermission(){return new Promise(((e,t)=>{Promise.all(this.options.sensors.map((e=>this.getPermissions(e).map((e=>navigator.permissions.query({name:e}))))).reduce(((e,t)=>[...e,...t]))).then((r=>{r.every((e=>"granted"===e.state))?e():t(new Error("No permission to use the required sensors!"))})).catch(t)}))}start(){return new Promise((e=>{if(this._running=!0,this._subscriptions.size>0)return e();this.options.sensors.forEach((e=>{const t=new(this.findSensor(e))({frequency:Math.round(1e3/this.options.interval)});t.addEventListener("reading",(t=>{this._running&&(this._values.set(e,t),this._isUpdated()&&(this._lastPush=n.TimeService.now(),this.createFrame().catch((e=>{this.logger("error","Unable to create sensor data frame!",e)}))))})),t.start(),this._subscriptions.set(e,t)})),e()}))}_isUpdated(){return Array.from(this._values.values()).filter((e=>e.timestamp>this._lastPush)).length===this.options.sensors.length}stop(){return new Promise((e=>{this.options.softStop?this._running=!1:(this._subscriptions.forEach((e=>e.stop())),this._subscriptions=new Map,this._values=new Map),e()}))}createFrame(){return new Promise((e=>{const t=new n.DataFrame;t.source=this.source;const r=this._values.get(n.Accelerometer),o=this._values.get(n.LinearAccelerationSensor),s=this._values.get(n.Gyroscope),i=this._values.get(n.AbsoluteOrientationSensor),a=this._values.get(n.RelativeOrientationSensor),c=this._values.get(n.Magnetometer),u=this.source?this.source.uid:this.uid,l=1e3/this.options.interval;r&&t.addSensor(new n.Accelerometer(u+"_accel",new n.Acceleration(r.x,r.y,r.z),l)),o&&t.addSensor(new n.LinearAccelerationSensor(u+"_linearaccel",new n.Acceleration(o.x,o.y,o.z),l)),s&&t.addSensor(new n.Gyroscope(u+"_gyro",new n.AngularVelocity(s.x,s.y,s.z,n.AngularVelocityUnit.RADIAN_PER_SECOND),l)),i&&t.addSensor(new n.AbsoluteOrientationSensor(u+"_absoluteorientation",n.Orientation.fromQuaternion(new n.Quaternion(...i.quaternion)),l)),a&&t.addSensor(new n.RelativeOrientationSensor(u+"_relativeorientation",n.Orientation.fromQuaternion(new n.Quaternion(...a.quaternion)),l)),c&&t.addSensor(new n.Magnetometer(u+"_mag",new n.Magnetism(c.x,c.y,c.z),l)),this.push(t),e()}))}onPull(){return new Promise((e=>{e(void 0)}))}findSensor(e){switch(e){case n.RelativeOrientationSensor:return RelativeOrientationSensor;case n.AbsoluteOrientationSensor:return AbsoluteOrientationSensor;case n.LinearAccelerationSensor:return LinearAccelerationSensor;case n.Gyroscope:return Gyroscope;case n.Magnetometer:return Magnetometer;case n.Accelerometer:return Accelerometer;default:return}}getPermissions(e){switch(e){case n.RelativeOrientationSensor:case n.AbsoluteOrientationSensor:return["gyroscope","accelerometer","magnetometer"];case n.Gyroscope:return["gyroscope"];case n.Magnetometer:return["magnetometer"];case n.LinearAccelerationSensor:case n.Accelerometer:return["accelerometer"];default:return}}}class SensorSourceNode_SensorSourceNode extends n.SourceNode{constructor(e){var t;super(e),this.options.source=null!==(t=this.options.source)&&void 0!==t?t:new n.DataObject(this.uid),this.options.autoStart&&this.once("build",this.start.bind(this)),this.once("destroy",this.stop.bind(this))}requestPermission(){return Promise.resolve()}start(){return new Promise((e=>{const t=this.source?this.source.uid:this.uid;window.addEventListener("devicemotion",(e=>{const r=new n.DataFrame,o=1e3/e.interval;r.addSensor(new n.Accelerometer(t+"_accl",new n.Acceleration(e.accelerationIncludingGravity.x,e.accelerationIncludingGravity.y,e.accelerationIncludingGravity.z),o)),r.addSensor(new n.Gyroscope(t+"_gyro",new n.AngularVelocity(e.rotationRate.beta,e.rotationRate.gamma,e.rotationRate.alpha),o)),r.addSensor(new n.Accelerometer(t+"_linearaccl",new n.Acceleration(e.acceleration.x,e.acceleration.y,e.acceleration.z),o));const s=this.source;s.getPosition().angularVelocity=r.getSensor(n.Gyroscope).value,r.addSensor(new n.AbsoluteOrientationSensor(t+"_orientation",s.getPosition().orientation)),r.source=s,this.push(r)}),!0),window.addEventListener("deviceorientation",(e=>{this.source.getPosition().orientation=n.Orientation.fromEuler([e.beta,e.gamma,e.alpha])})),this.logger("debug","Browser orientation and motion events registered!"),e()}))}stop(){return Promise.resolve()}onPull(){return new Promise((e=>{e(void 0)}))}}(t=o.hmd(t)).exports="Accelerometer"in window?{SensorSourceNode}:{SensorSourceNode:SensorSourceNode_SensorSourceNode}}},r={};function o(e){var n=r[e];if(void 0!==n)return n.exports;var s=r[e]={id:e,loaded:!1,exports:{}};return t[e](s,s.exports,o),s.loaded=!0,s.exports}o.d=(e,t)=>{for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.hmd=e=>((e=Object.create(e)).children||(e.children=[]),Object.defineProperty(e,"exports",{enumerable:!0,set:()=>{throw new Error("ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: "+e.id)}}),e),o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);o(229);
//# sourceMappingURL=openhps-web-sensors.es.min.js.map